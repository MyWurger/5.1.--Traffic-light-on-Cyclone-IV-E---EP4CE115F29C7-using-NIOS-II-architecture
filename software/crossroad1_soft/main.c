#include "sys/alt_stdio.h"           // библиотека для работы с портами ввода/вывода ПЛИС
#include "unistd.h"                  // библиотека предоставляет доступ к некоторым функциям и константам POSIX
#include "system.h"                  // библиотека используется для работы с переключателями и светодиодами, подключенными к ядру PIO
#include "altera_avalon_pio_regs.h"  // библиотека предоставляет функции и макросы для непосредственного чтения/записи регистров ядра PIO

// определяем регистры ядра PIO
typedef struct
{
	unsigned long int DATA;            // определяет состояние выходных портов ядра PIO. Эта переменная работает как выходной буфер, который может быть использован для управления внешними устройствами.
	unsigned long int DIRECTION;       // определяет направление данных на входных и выходных портах ядра PIO.  Если значение переменной DIRECTION установлено в 0, то порт используется для вывода данных. Если значение установлено в 1, то порт используется для ввода данных.
	unsigned long int INTERRUPT_MASK;  // определяет маску прерываний для соответствующего порта. Если соответствующий бит установлен в 1, то прерывания от данного порта будут запрещены. Если бит установлен в 0, то прерывания будут разрешены.
	unsigned long int EDGE_CAPTURE;    // определяет обнаружение фронтов для каждого входного порта. Если флаг установлен в 1, это означает, что произошло переключение на передний фронт импульса на соответствующем пине порта
} PIO_STR;

// Макрос LEDS определяет указатель на структуру PIO_STR
// LEDS_BASE предполагается быть базовым адресом регистров ядра PIO
// Путем определения макроса LEDS, базовый адрес регистров приводится к типу указателя на структуру PIO_STR,
// что позволяет обращаться к регистрам ядра PIO через этот макрос.

// Макрос LEDS используется в коде для управления светодиодами на основе состояния переключателей, подключенных к ядру PIO

#define LEDS ((PIO_STR *) LEDS_BASE)

// ОСНОВНАЯ ФУНКЦИЯ
int main()
{
	int sw = -1;      // от состояния sw, код устанавливает режимы работы и состояние светодиодов, подключенных к адресу LEDS_BASE интерфейса PIO
	int state = 0;    // значение используется для "самопереключения" состояний светофора

        // бесконечный цикл работы светофора
	while (1)
	{
                // проверка состояния переключателей. Считывание и сохранение в sw
		sw = IORD_ALTERA_AVALON_PIO_DATA(SWITCHES_BASE);

                // все задействованные LED переливаются – светодиоды поочередно переключаются с интервалом 50 миллисекунд
		if (sw == 1)
		{
			LEDS->DATA = 1;
			usleep(50000);
			LEDS->DATA = 2;
			usleep(50000);
			LEDS->DATA = 4;
			usleep(50000);
			LEDS->DATA = 8;
			usleep(50000);
			LEDS->DATA = 16;
			usleep(50000);
			LEDS->DATA = 32;
			usleep(50000);
                        // устанавливаем неопределённый режим работы до следующего считывания состояния переключателей
			sw = -1;
		}

                // все задействованные светодиоды мигают, что имитирует перевод светофоров на мигающий режим работы с интеревалом 300 миллисекунд
		else if(sw == 2)
		{
                                // светофоры все зажглись
				LEDS->DATA = 1 | 2 | 4 | 8 | 16 | 32;
                                // подождали пока включены
				usleep(300000);
                                // погасили светофоры
				LEDS->DATA = 0;
                                // подержали их выключенными
				usleep(50000);
                                // устанавливаем неопределённый режим работы до следующего считывания состояния переключателей
				sw = -1;
		}

                // иначе - нормальный режим работы светофорв перекрёстка. Они самопроизвольно переключаются
                // включение определённых светодиодов в определённые периоды времени. Значения комбинируются побитовой логикой
		else
		{
			if(state == 0)
			{
				LEDS->DATA = 1 | 4 | 32;
				usleep(2000000);
			}
			else if(state == 1)
			{
				LEDS->DATA = 2 | 8 | 16 ;
				usleep(1000000);
			}
			else if( state == 2)
			{
				LEDS->DATA = 1 | 8 | 16;
				usleep(1500000);
			}
			else if(state == 3)
			{
				LEDS->DATA = 2| 4 | 16;
				usleep(1500000);
			}
		}
                // переходим в следующее состояние по счётчику состояний
		state++;

                // сброс в начальное состояние после прохождения всего цикла работы светофора
		if (state == 4)
                {
                  state = 0;
                }
	}
	return 0;
}
